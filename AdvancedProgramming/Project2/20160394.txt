1. 문제정의
① 클래스 정의 : 실수부, 허수부 변수 필요. private 멤버 변수 접근 위한 get()함수 필요.

② 복소수 op 복소수 : 
+의 경우, 실수부는 실수부끼리, 허수부는 허수부끼리 덧셈.
-의 경우, 실수부는 실수부끼리, 허수부는 허수부끼리 뺄셈.
*의 경우, 복소수끼리 곱셈방식에 따름.
/의 경우, 분수형태의 복소수를 변환하는 복소수끼리 나눗셈방식에 따름.

③ 복소수 op 실수 : 복소수 op 복소수 방식에서 automatic type casting이 가능하다고 판단함.
		따라서 따로 구현은 안함.

④ 실수 op 복소수 :
+의 경우, 복소수의 실수부에 실수를 덧셈.
-의 경우, 복소수의 실수부에 실수를 뺄셈.
*의 경우, 복소수의 실수부와 허수부에 각각 실수를 곱셈.
/의 경우, 분수형태의 복소수를 변환하는 복소수끼리 나눗셈방식에 따름. 
	이때 실수를 허수부분이 0인 복소수로 생각할 수 있으므로 복소수 op 복소수의 나눗셈과 같은 방식을 취함.

⑤ cout 출력 : ostream& operator << 오버로딩 필요.

⑥ Divide by Zero : 각 나눗셈 연산시 분수부분의 복소수가 0이면 에러 발생


2. 프로그램 설계
① 클래스 정의 : 실수부와 허수부 변수를 double 형태로 선언. 각각 get함수 구현.
	         각 사칙연산은 멤버변수에 접근할 필요가 있으므로 friend함수 형태로 선언.

② 복소수 op 복소수 : 문제정의 부분에서 정의한 방식대로 구현. 
		    각 사칙연산 연산자를 오버로딩함. return은 NComplex() 클래스로 반환.

③ 복소수 op 실수 : 문제정의 부분대로 따로 구현은 안함. Automatic type casting이 가능하다고 판단함.

④ 실수 op 복소수 : 문제정의 부분에서 정의한 방식대로 구현. return은 NComplex() 클래스로 반환.
		 각 사칙연산 연산자를 오버로딩함. return은 NComplex() 클래스로 반환.

⑤ cout 출력 : << 연산자를 오버로딩하고 "실수 + 허수i" 형태로 출력하게함.

⑥ Divide by Zero : 
복소수 op 복소수 -> 분수 부분의 복소수의 실수부와 허수부가 0이면 에러출력, 이후 exit()으로 종료됨.
복소수 op 실수 -> 복소수 op 복소수 에서 automatic type casting되므로 동일함.
실수 op 복소수 -> 복소수 op 복소수 에서 분자 부분의 복소수의 허수부가 0인 복소수로 생각해볼 수 있음.
		따라서 복소수 op 복소수와 동일함.